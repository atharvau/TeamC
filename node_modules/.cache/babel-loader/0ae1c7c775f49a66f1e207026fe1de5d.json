{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types')) : typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types'], factory) : factory(global.ReactMinimalPieChart = {}, global.React, global.PropTypes);\n})(this, function (exports, React, PropTypes) {\n  'use strict';\n\n  var React__default = 'default' in React ? React['default'] : React;\n  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes; // from http://stackoverflow.com/a/18473154\n\n  var partialCircle = function partialCircle(cx, cy, r, start, end) {\n    var length = end - start;\n    if (length === 0) return [];\n    var fromX = r * Math.cos(start) + cx;\n    var fromY = r * Math.sin(start) + cy;\n    var toX = r * Math.cos(end) + cx;\n    var toY = r * Math.sin(end) + cy;\n    var large = Math.abs(length) <= Math.PI ? '0' : '1';\n    var sweep = length < 0 ? '0' : '1';\n    return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];\n  };\n\n  var svgPartialCircle = partialCircle;\n\n  var classCallCheck = function classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var inherits = function inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n\n  var objectWithoutProperties = function objectWithoutProperties(obj, keys) {\n    var target = {};\n\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n\n    return target;\n  };\n\n  var possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n\n  var PI = Math.PI;\n\n  var degreesToRadians = function degreesToRadians(degrees) {\n    return degrees * PI / 180;\n  };\n\n  var makePathCommands = function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {\n    var patchedLengthAngle = lengthAngle;\n    if (patchedLengthAngle >= 360) patchedLengthAngle = 359.999;\n    if (patchedLengthAngle <= -360) patchedLengthAngle = -359.999;\n    return svgPartialCircle(cx, cy, // center X and Y\n    radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {\n      return command.join(' ');\n    }).join(' ');\n  };\n\n  function ReactMinimalPieChartPath(_ref) {\n    var cx = _ref.cx,\n        cy = _ref.cy,\n        startAngle = _ref.startAngle,\n        lengthAngle = _ref.lengthAngle,\n        radius = _ref.radius,\n        lineWidth = _ref.lineWidth,\n        reveal = _ref.reveal,\n        title = _ref.title,\n        props = objectWithoutProperties(_ref, ['cx', 'cy', 'startAngle', 'lengthAngle', 'radius', 'lineWidth', 'reveal', 'title']);\n    var actualRadio = radius - lineWidth / 2;\n    var pathCommands = makePathCommands(cx, cy, startAngle, lengthAngle, actualRadio);\n    var strokeDasharray = void 0;\n    var strokeDashoffset = void 0; // Animate/hide paths with \"stroke-dasharray\" + \"stroke-dashoffset\"\n    // https://css-tricks.com/svg-line-animation-works/\n\n    if (typeof reveal === 'number') {\n      strokeDasharray = PI * actualRadio / 180 * Math.abs(lengthAngle);\n      strokeDashoffset = strokeDasharray + strokeDasharray / 100 * reveal;\n    }\n\n    return React__default.createElement('path', _extends({\n      d: pathCommands,\n      strokeWidth: lineWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset\n    }, props), title && React__default.createElement('title', null, title));\n  }\n\n  ReactMinimalPieChartPath.displayName = 'ReactMinimalPieChartPath';\n  ReactMinimalPieChartPath.propTypes = {\n    cx: PropTypes.number.isRequired,\n    cy: PropTypes.number.isRequired,\n    startAngle: PropTypes.number,\n    lengthAngle: PropTypes.number,\n    radius: PropTypes.number,\n    lineWidth: PropTypes.number,\n    reveal: PropTypes.number,\n    title: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n  };\n  ReactMinimalPieChartPath.defaultProps = {\n    startAngle: 0,\n    lengthAngle: 0,\n    lineWidth: 100,\n    radius: 100\n  };\n  var VIEWBOX_SIZE = 100;\n  var VIEWBOX_HALF_SIZE = VIEWBOX_SIZE / 2;\n\n  var sumValues = function sumValues(data) {\n    return data.reduce(function (acc, dataEntry) {\n      return acc + dataEntry.value;\n    }, 0);\n  };\n\n  var evaluateViewBoxSize = function evaluateViewBoxSize(ratio, baseSize) {\n    // Wide ratio\n    if (ratio > 1) {\n      return baseSize + ' ' + baseSize / ratio;\n    } // Narrow/squared ratio\n\n\n    return baseSize * ratio + ' ' + baseSize;\n  }; // @TODO extract padding evaluation\n\n\n  var evaluateDegreesFromValues = function evaluateDegreesFromValues(data, totalAngle, totalValue, paddingAngle) {\n    var total = totalValue || sumValues(data); // Remove segments padding from total degrees\n\n    var degreesTakenByPadding = paddingAngle * data.length;\n    var totalDegrees = Math.abs(totalAngle) - degreesTakenByPadding;\n    if (totalDegrees > 360) totalDegrees = 360;\n    if (totalAngle < 0) totalDegrees = -totalDegrees; // Append \"degrees\" into each data entry\n\n    return data.map(function (dataEntry) {\n      return Object.assign({\n        degrees: dataEntry.value / total * totalDegrees\n      }, dataEntry);\n    });\n  };\n\n  var makeSegmentTransitionStyle = function makeSegmentTransitionStyle(duration, easing) {\n    var furtherStyles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Merge CSS transition necessary for chart animation with the ones provided by \"segmentsStyle\"\n\n    var transition = ['stroke-dashoffset ' + duration + 'ms ' + easing, furtherStyles.transition].filter(Boolean).join(',');\n    return {\n      transition: transition\n    };\n  };\n\n  var makeSegments = function makeSegments(data, props, hide) {\n    // Keep track of how many degrees have already been taken\n    var lastSegmentAngle = props.startAngle;\n    var segmentsPaddingAngle = props.paddingAngle * (props.lengthAngle / Math.abs(props.lengthAngle));\n    var reveal = void 0;\n    var style = props.segmentsStyle;\n\n    if (props.animate) {\n      var transitionStyle = makeSegmentTransitionStyle(props.animationDuration, props.animationEasing, style);\n      style = Object.assign({}, style, transitionStyle);\n    } // Hide/reveal the segment?\n\n\n    if (hide === true) {\n      reveal = 0;\n    } else if (typeof props.reveal === 'number') {\n      reveal = props.reveal;\n    } else if (hide === false) {\n      reveal = 100;\n    }\n\n    return data.map(function (dataEntry, index) {\n      var startAngle = lastSegmentAngle;\n      lastSegmentAngle += dataEntry.degrees + segmentsPaddingAngle;\n      return React__default.createElement(ReactMinimalPieChartPath, {\n        key: dataEntry.key || index,\n        cx: props.cx,\n        cy: props.cy,\n        startAngle: startAngle,\n        lengthAngle: dataEntry.degrees,\n        radius: props.radius,\n        lineWidth: props.radius / 100 * props.lineWidth,\n        reveal: reveal,\n        style: style,\n        stroke: dataEntry.color,\n        strokeLinecap: props.rounded ? 'round' : undefined,\n        fill: 'none',\n        onMouseOver: props.onMouseOver && function (e) {\n          return props.onMouseOver(e, props.data, index);\n        },\n        onMouseOut: props.onMouseOut && function (e) {\n          return props.onMouseOut(e, props.data, index);\n        },\n        onClick: props.onClick && function (e) {\n          return props.onClick(e, props.data, index);\n        }\n      });\n    });\n  };\n\n  var ReactMinimalPieChart = function (_PureComponent) {\n    inherits(ReactMinimalPieChart, _PureComponent);\n\n    function ReactMinimalPieChart(props) {\n      classCallCheck(this, ReactMinimalPieChart);\n\n      var _this = possibleConstructorReturn(this, _PureComponent.call(this, props));\n\n      if (_this.props.animate === true) {\n        _this.hideSegments = true;\n      }\n\n      return _this;\n    }\n\n    ReactMinimalPieChart.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.props.animate === true && requestAnimationFrame) {\n        this.initialAnimationTimerId = setTimeout(function () {\n          _this2.initialAnimationTimerId = null;\n          _this2.initialAnimationRAFId = requestAnimationFrame(function () {\n            _this2.initialAnimationRAFId = null, _this2.startAnimation();\n          });\n        });\n      }\n    };\n\n    ReactMinimalPieChart.prototype.componentWillUnmount = function componentWillUnmount() {\n      if (this.initialAnimationTimerId) {\n        clearTimeout(this.initialAnimationTimerId);\n      }\n\n      if (this.initialAnimationRAFId) {\n        cancelAnimationFrame(this.initialAnimationRAFId);\n      }\n    };\n\n    ReactMinimalPieChart.prototype.startAnimation = function startAnimation() {\n      this.hideSegments = false;\n      this.forceUpdate();\n    };\n\n    ReactMinimalPieChart.prototype.render = function render() {\n      if (this.props.data === undefined) {\n        return null;\n      }\n\n      var normalizedData = evaluateDegreesFromValues(this.props.data, this.props.lengthAngle, this.props.totalValue, this.props.paddingAngle);\n      return React__default.createElement('div', {\n        className: this.props.className,\n        style: this.props.style\n      }, React__default.createElement('svg', {\n        viewBox: '0 0 ' + evaluateViewBoxSize(this.props.ratio, VIEWBOX_SIZE),\n        width: '100%',\n        height: '100%',\n        style: {\n          display: 'block'\n        }\n      }, makeSegments(normalizedData, this.props, this.hideSegments)), this.props.children);\n    };\n\n    return ReactMinimalPieChart;\n  }(React.PureComponent);\n\n  ReactMinimalPieChart.displayName = 'ReactMinimalPieChart';\n  ReactMinimalPieChart.propTypes = {\n    data: PropTypes.arrayOf(PropTypes.shape({\n      title: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n      value: PropTypes.number.isRequired,\n      key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n      color: PropTypes.string\n    })),\n    cx: PropTypes.number,\n    cy: PropTypes.number,\n    ratio: PropTypes.number,\n    totalValue: PropTypes.number,\n    className: PropTypes.string,\n    style: PropTypes.objectOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),\n    segmentsStyle: PropTypes.objectOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),\n    startAngle: PropTypes.number,\n    lengthAngle: PropTypes.number,\n    paddingAngle: PropTypes.number,\n    lineWidth: PropTypes.number,\n    radius: PropTypes.number,\n    rounded: PropTypes.bool,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    animationEasing: PropTypes.string,\n    reveal: PropTypes.number,\n    children: PropTypes.node,\n    onMouseOver: PropTypes.func,\n    onMouseOut: PropTypes.func,\n    onClick: PropTypes.func\n  };\n  ReactMinimalPieChart.defaultProps = {\n    cx: VIEWBOX_HALF_SIZE,\n    cy: VIEWBOX_HALF_SIZE,\n    ratio: 1,\n    startAngle: 0,\n    lengthAngle: 360,\n    paddingAngle: 0,\n    lineWidth: 100,\n    radius: VIEWBOX_HALF_SIZE,\n    rounded: false,\n    animate: false,\n    animationDuration: 500,\n    animationEasing: 'ease-out',\n    onMouseOver: undefined,\n    onMouseOut: undefined,\n    onClick: undefined\n  };\n  exports['default'] = ReactMinimalPieChart;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}